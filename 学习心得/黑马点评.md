# 一、短信登陆
## 集群Session问题
每个Tomcat服务器都有自己独立的Session空间，多个Tomcat服务器不会共享Session存储空间，因此当请求切换到其他的Tomcat服务器时，由于该服务器的Session中并没有保存用户相关信息，因此请求会被拦截，需要用户重新进行登录校验，导致用户体验感变差。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691048466795-847d7772-0269-4044-b9fa-bd236b39f42d.png#averageHue=%23fcf7f7&clientId=u1bdc915e-f09d-4&from=paste&height=593&id=ub229573d&originHeight=593&originWidth=1315&originalType=binary&ratio=1&rotation=0&showTitle=false&size=205161&status=done&style=none&taskId=u41d15ca8-f27f-440b-85c1-1e0b55018ce&title=&width=1315)
**解决方案：**

1. Session拷贝
   1. 在不同的session中存储相同数据，浪费空间
   2. 维护数据同步浪费资源
   3. 数据不一致
2. 替代Session
   1. session中存储的是登录校验的数据，在每次请求中都会被访问。而session是基于内存的，读写效率高。因此要求替代品要求有较高的读写效率（基于内存）
   2. 能实现数据共享（Redis独立于Tomcat之外，任何一个tomcat都能访问到redis）
   3. key、value结构
## Redis保存数据
将验证码和用户信息保存到redis中。保存用户信息到redis中时，考虑到后续每次请求都会通过key，找到value；通过判断value是否存来进行登录校验。因此需要设计合适的key。

| key | value |
| --- | --- |
| phone:13507690339 | 9874 |
| tocken: | {name:;} |

**特殊情况：**
在拦截器中只拦截了必须登录才有权限看到的页面，对于首页等这种无需登录的页面并没有拦截。如果用户一直在这种页面中，那么tokcen的有效期就不会刷新，因此tocken到时间之后会失效。
**需求：**只要用户在浏览页面，就让tocken刷新。因此设置两个拦截器，第一个拦截器拦截所有页面，用于刷新tocken；第二个拦截器进行身份校验。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691050904279-e268b922-f90a-409a-ba5e-0bebbd34a037.png#averageHue=%23818285&clientId=u1bdc915e-f09d-4&from=paste&height=722&id=u7eff22c4&originHeight=722&originWidth=1547&originalType=binary&ratio=1&rotation=0&showTitle=false&size=206826&status=done&style=none&taskId=ua33e70e6-1d1b-49f4-a6b7-26fdc4c479f&title=&width=1547)
**优化：**
**使用JWT来进行登录校验。这样就不需要再将用户的信息保存到redis中，而是可以在tocken中获取用户信息。**
# 二、缓存
**缓存：**数据交换的缓冲区，临时存储数据的地方，读写性能比较高
实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用

**浏览器缓存**：主要是存在于浏览器端的缓存
**应用层缓存**：可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存
**数据库缓存：**在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中
**CPU缓存：**当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691114486248-28f9e8a0-fb32-4267-9bfd-6c4df58b9ee7.png#averageHue=%23fcfcfc&clientId=u1bdc915e-f09d-4&from=paste&height=545&id=udc62cce3&originHeight=545&originWidth=1349&originalType=binary&ratio=1&rotation=0&showTitle=false&size=71444&status=done&style=none&taskId=u02f67b76-bc84-4142-9015-c425fd60729&title=&width=1349)
## 缓存更新
> 已经存储到redis中的数据，什么时候会触发更新操作？

1. **内存淘汰**

当Redis的内存满了之后，触发内存淘汰机制，自动淘汰掉Redis中的一部分数据

2. **超时剔除**

当向Redis中存储数据时，设置数据的过期时间，到期自动删除。下次查询时发现缓存不存在，从数据库中查询，再写入到缓存中。
不足：若数据在有效期内进行了修改，从Redis中获取的仍然是旧数据

3. **主动更新**

由程序员编写业务逻辑，当修改数据库时，同时更新缓存中的数据。
### 主动更新策略

1. Cache Aside Pattern
2. 

## 缓存穿透
> 项目中对商铺信息进行了缓存，如果在某一时刻有大量请求去查询了不存在的商铺，造成缓存穿透现象，该怎么解决？

### 缓存空对象
先查询缓存，判断商铺信息是否存在。如果存在，还需判断商铺对应的Key缓存的Value是否是空对象("")。如果是的话，则返回店铺不存在的错误信息。如果不是空对象的话，则说明数据库中有该商铺信息的数据。则到数据库中进行查询，并存入到redis中。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691744029562-efc0d838-4b39-45e1-b313-a4e2bc8d1589.png#averageHue=%23efeef0&clientId=ue5a65cfe-6ee2-4&from=paste&height=691&id=u7787eb3a&originHeight=691&originWidth=724&originalType=binary&ratio=1&rotation=0&showTitle=false&size=158514&status=done&style=none&taskId=ub3f596f3-b460-400c-8162-e99003e420d&title=&width=724)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691744162956-0e73a5d4-6d59-4113-a413-83799433e06d.png#averageHue=%23f2f5f1&clientId=ue5a65cfe-6ee2-4&from=paste&height=561&id=u138c120b&originHeight=561&originWidth=1122&originalType=binary&ratio=1&rotation=0&showTitle=false&size=290756&status=done&style=none&taskId=uaf0ed36e-e5f9-4e01-9f26-83b2b3c45c4&title=&width=1122)
### 布隆过滤器
### 增加ID复杂度，避免被猜测ID规律
防止被猜到不存在数据库中的ID，而被恶意的向这些ID发起大量查询请求
### 对ID进行格式校验
先对ID进行校验，把不符合格式的ID的请求过滤掉
### 对热点参数做限流
## 缓存雪崩
**解决方案**

1. **为不同的Key的TTL添加随机值**（如果是做了**缓存预热**，批量将一批key添加至缓存，并设置TTL，那么为了不让这批key同一时间过期而导致缓存血崩的问题，将key设置30min+产生的一个随机数，让TTL随机）
2. **利用Redis集群提高服务的可用性**（**解决宕机**导致Redis雪崩的思路）
3. **给缓存业务添加降级限流的策略**（比如当Redis的**整个集群都宕机**时，添加快速失败、拒绝服务等策略）
4. **给业务添加多级缓存**（**多个层面建立缓存**，一个缓存崩掉了，还有其他的缓存起一个缓冲作用，浏览器本地->Nginx->Redis->JVM->数据库，像京东为商品详情就做了多级缓存，从而应对亿级以上的并发）
## 缓存击穿
缓存击穿问题也叫热点Key问题，就是一个被**高并发访问（比如秒杀商品）**并且**缓存重建业务较复杂（比如这个数据需要多表关联运算，查取比较耗时）**的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691825342901-7667b49b-a6c4-4ea6-806d-a318e9458239.png#averageHue=%23eeedee&clientId=ud5927d69-6b98-4&from=paste&height=621&id=u3ce87e59&originHeight=621&originWidth=1017&originalType=binary&ratio=1&rotation=0&showTitle=false&size=147611&status=done&style=none&taskId=uf9bcddb6-3947-4c4c-929d-aa54ba4e01b&title=&width=1017)
**解决方案：**

1. **互斥锁（一致性）
优点：**没有额外的内存消耗（没有添加expire字段）
	  保证了强一致性
	  实现简单
**缺点：**性能较低（其中一个线程进行缓存重建时，其他想要读取该数据的线程都会处于等待状态）
	  有死锁风险
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691825453595-8bddc0a9-7a03-44f3-b925-9f6bc498f302.png#averageHue=%23eeedee&clientId=ud5927d69-6b98-4&from=paste&height=388&id=uc84271f4&originHeight=732&originWidth=570&originalType=binary&ratio=1&rotation=0&showTitle=false&size=134993&status=done&style=none&taskId=u10c65ee3-ce48-407e-8838-50b8a8b1c4c&title=&width=302)
2. **逻辑过期（可用性）（一般是为热点Key设置逻辑过期，比如某一秒杀商品详情信息，当秒杀商品下架时，再把该key从Redis中移除。）**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691825534186-8056dc83-b0ba-4d91-a3f7-8903178b2cbb.png#averageHue=%23fafcfb&clientId=ud5927d69-6b98-4&from=paste&height=100&id=u7eca0727&originHeight=100&originWidth=868&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35795&status=done&style=none&taskId=u17f50e6a-4219-44ea-8aec-996a20ff74e&title=&width=868)
**优点：**性能较好，线程无须等待
**缺点：**不保证一致性
	  有额外内存消耗（添加了expire字段）
	  实现复杂
在向Redis中添加数据时，设置一个逻辑过期字段expire，值为存入的系统当前时间+有效期
**流程：**线程1查询Redis，发现数据过期，则获取互斥锁，同时开启另一个线程去读取数据库的数据，重建缓存。线程1仍然读取旧数据，并缓存。此时其他线程从Redis中查询数据，发现逻辑过期，尝试获取互斥锁来重建缓存。但获取互斥锁失败，则返回过期数据。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691826072497-42227dd8-8124-41d8-aff6-0f493e59f0b4.png#averageHue=%23efeeef&clientId=ud5927d69-6b98-4&from=paste&height=725&id=u9c02cdc8&originHeight=725&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&size=200228&status=done&style=none&taskId=u4ce98b79-e7f1-449b-8210-bb446e7fede&title=&width=943)
### 互斥锁实现
由于Redis中设置Key时，有一个命令SETNX，它只有key不存在时，才会设置值，同时返回结果1。如果key不存在，则返回0。因此可以通过它来实现互斥锁，如果有一个线程想要获取互斥锁，则根据SETNX来为某一个key设置值，同时返回true，那么该线程则知道获取锁成功。其他的线程想要获取该互斥锁时，发现SETNX返回的结果为0，则知道已经有线程获取了该锁。当持有互斥锁的线程进行缓存重建后，要释放互斥锁，否则其他线程将会一直处于重试等待状态。
另外，考虑到如果释放互斥锁执行失败，导致锁没有释放掉，其他线程一直等待，因此可以在SETNX时，为互斥锁的key添加过期时间。比如缓存重建业务的时间可能为100ms，则设置互斥锁的过期时间为它的10倍左右，设置为1000ms。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691826930178-d411edb3-3ecc-4b43-baa7-a910c6c1a6d9.png#averageHue=%23fdfafa&clientId=ud5927d69-6b98-4&from=paste&height=662&id=udd433e5e&originHeight=662&originWidth=985&originalType=binary&ratio=1&rotation=0&showTitle=false&size=185297&status=done&style=none&taskId=uba10a651-cc56-4f09-a294-1cf3a2db242&title=&width=985)
```java
// 获取锁
private boolean tryLock(String key) {
    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);
    return BooleanUtil.isTrue(flag);
}
// 释放锁
private void unlock(String key) {
    stringRedisTemplate.delete(key);
}

```
```java
public Shop queryShopByIdSolvePenetrateWithWriteMutex(Long id) {
        String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);
        //如果redis未命中查数据库
        if (StrUtil.isNullOrUndefined(shopJson)){
            //在查数据库之前先获取锁
            String lockKey=LOCK_SHOP_KEY+id;
            try {
                boolean isLock = tryLock(lockKey);
                if (!isLock){
                    //如果获取锁失败了休眠一段时间后重试
                    Thread.sleep(50);
                    return queryShopByIdSolvePenetrateWithWriteMutex(id);
                }
                //以下为获得锁成功
                Shop shop = shopService.getById(id);
                //数据库也不存则写入空数据到Redis
                if (shop==null){
                    //
                    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id,"",CACHE_NULL_TTL,TimeUnit.MINUTES);
                    queryShopByIdSolveBreakWithWriteNull(id);
                }
                //数据库存在则将数据写进redis
                shopJson = JSONUtil.toJsonStr(shop);
                stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id,shopJson,CACHE_SHOP_TTL,TimeUnit.MINUTES);
                //写进缓存后再释放锁
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                unlock(lockKey);
            }
            //重新查一遍，就可以从redis获得数据
            return queryShopByIdSolveBreakWithWriteNull(id);
        }
        //如果命中了redis,但是为空,直接返回空对象
        if (StrUtil.isBlank(shopJson)){
            return null;
        }
        //如果命中了redis且不为空,重置时间
        stringRedisTemplate.expire(CACHE_SHOP_KEY+id,CACHE_SHOP_TTL,TimeUnit.MINUTES);
        Shop shop = JSONUtil.toBean(shopJson, Shop.class);
        return shop;
    }
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691827595420-4acc0fd4-e1a8-4a17-b218-10e0e3eaae59.png#averageHue=%23f3f7f2&clientId=ud5927d69-6b98-4&from=paste&height=849&id=uea613fbd&originHeight=849&originWidth=1554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=493529&status=done&style=none&taskId=ud69056ff-d926-470d-942a-4b055a8709f&title=&width=1554)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691827952813-23bfd29e-dc15-470a-9101-9767136bcd1e.png#averageHue=%23c1d0de&clientId=ud5927d69-6b98-4&from=paste&height=711&id=u229b87b9&originHeight=711&originWidth=1755&originalType=binary&ratio=1&rotation=0&showTitle=false&size=224990&status=done&style=none&taskId=ucf843899-7dc8-4f23-9a1b-18826cf7cf1&title=&width=1755)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691827983300-73b26cf3-eac2-47cc-8b78-a73c9fb848f1.png#averageHue=%23bdd1e0&clientId=ud5927d69-6b98-4&from=paste&height=440&id=u72594c43&originHeight=440&originWidth=1750&originalType=binary&ratio=1&rotation=0&showTitle=false&size=225787&status=done&style=none&taskId=uaa35bc31-8042-48ec-9813-eb802facbc5&title=&width=1750)
### 逻辑过期实现
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691828166895-54166c8f-ccad-4931-8f14-df566f984555.png#averageHue=%23fcf9f9&clientId=ud5927d69-6b98-4&from=paste&height=671&id=u0331a800&originHeight=671&originWidth=1239&originalType=binary&ratio=1&rotation=0&showTitle=false&size=225372&status=done&style=none&taskId=ue4274817-0cff-4e2e-b5ff-409dfa4f09e&title=&width=1239)
> 逻辑过期字段怎么添加？

1. 直接在实体类中添加逻辑过期字段（违背开闭原则）
2. 设计一个新的类，类里有逻辑过期字段，让实体类继承该类（仍然违背开闭原则）
3. 设计一个新的类，类里有逻辑过期以及实体类两个属性（采用）
```java
@Data
public class RedisData {
    private LocalDateTime expireTime;
    private Object data;
}
```
> 逻辑过期代码如何实现？

由于需要开启一个独立线程去执行缓存重建，因此创建了一个线程池（线程的创建和销魂不用我们关心），并在线程池里去提交缓冲重建的任务。
```java
//创建一个固定线程池
private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);
/**
     * 用逻辑过期时间解决缓存穿透
     * @param id
     * @return
     */
    public Shop queryShopByIdSolvePenetrateWithWriteLogicalExpireTime(Long id) {
        String redisDataJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);
        //如果redis未命中查数据库
        if (StrUtil.isEmpty(redisDataJson)){
            //未命中说明不是热点数据（会把热点数据进行缓存预热，存入到Redis中），转入处理缓存击穿的函数            
            return null;
        }
        //如果命中了redis且不为空，将其反序列化成对象，拿到逻辑过期时间
        RedisData redisData = JSONUtil.toBean(redisDataJson, RedisData.class);
        Shop shop = JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);
        LocalDateTime expireTime = redisData.getExpireTime();
        //如果时间已经过期，直接返回旧数据并开启新线程修改数据
        if (expireTime.isBefore(LocalDateTime.now())){
            //在开启新线程之前获得锁，锁的名称要与锁的id关联，修改不同的id可以并行，一样的id才需要加锁
            String lockKey=LOCK_SHOP_KEY+id;
            try {
                boolean isLock = tryLock(lockKey);
                //获取锁成功
                if (isLock){
                    //开启新线程用线程池，性能比自己创建线程好
                    CACHE_REBUILD_EXECUTOR.execute(()->{
                        //重建缓存
                        saveShopWithExpireTimeToRedis(id,30L);
                    });
                }
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                unlock(lockKey);
            }
        }
        return shop;
    }
```
# 三、秒杀问题
**优惠券字段结构**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691831777614-f7826c44-0560-45aa-866d-613317d9a300.png#averageHue=%23f8f6fa&clientId=ud5927d69-6b98-4&from=paste&height=316&id=u1921a0f2&originHeight=316&originWidth=1138&originalType=binary&ratio=1&rotation=0&showTitle=false&size=305642&status=done&style=none&taskId=u7d2beaf3-e401-41ab-a11e-00827ca4c80&title=&width=1138)
## 全局唯一ID
>  如果订单ID为自增型，会存在什么样的问题？（订单特点：数据量大、唯一）

1. **ID规律太明显。**由于订单ID会暴露给用户，因此用户可以从ID推测出一些信息。（比如，今天某一用户下订单时，订单ID为100；到第二天，下订单时订单ID为200，因此如果是自增的话，用户就能推测到在此期间卖掉了100单。）
2. **受单表数据量的限制**（如果采取自增，则之后对表做拆分，会出现订单重复）
> 全局唯一ID生成策略有哪些

1. **UUID**（十六进制字符串，无单调递增的特性）
2. **Redis自增**
3. **snowflake算法**（采用long类型64位数字，和下面采用的Redis生成ID策略很相似）
自增采用的当前机器的自增，而Redis是不管用的任何分布式系统，都是用的Redis作为自增。
4. **数据库自增**
### 全局ID生成器（把Redis作为全局ID生成器）
由于Redis是全局的，独立于Mysql之外的，因此可以使用Redis中的自增数值来实现生成全局唯一ID
**特点：**

1. **唯一性**
2. **高可用**（找该生成器生成ID时，这个生成器不能宕机）
3. **高性能**（生成ID速度快）
4. **递增性**（递增的话，方便建立和维护索引）
5. **安全性**（不能被用户猜测到ID规律）

ID采用数值类型（long型8个字节），数值类型在数据库中占用空间更小且建立索引更方便
如果时间戳相同，可以通过序列号来生成不同ID
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691836282305-54cf87f0-7f91-44a4-8179-4822dbc50c4c.png#averageHue=%23f8f6f8&clientId=ud5927d69-6b98-4&from=paste&height=633&id=uf767944f&originHeight=633&originWidth=1392&originalType=binary&ratio=1&rotation=0&showTitle=false&size=221839&status=done&style=none&taskId=u838a9ae2-6bfb-4b6a-abc2-5882de9a082&title=&width=1392)
### 代码实现
> 生成的序列号为什么还要拼接上时间？

Reids的自增数值上限2^64，如果对于一个业务，全都按照相同的key递增，那么经过几年之后可能就会出现数值超出的异常。
**解决（一天一个key）：**以天为单位，拼上时间，每一天都有不同的key，让其重新递增。另外这种方式还可以起到一个统计的效果。
```java
long count = stringRedisTemplate.opsForValue().increment("icr:" + keyPrefix); //并没有采取这种方案
// 2.生成序列号
// 2.1.获取当前日期，精确到天
String date = now.format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));
// 2.2.自增长
long count = stringRedisTemplate.opsForValue().increment("icr:" + keyPrefix + ":" + date);
```
> 如何将时间戳和序列号进行拼接？

由于返回的为long型，因此不能利用String进行简单的拼接。让时间戳在高位而序列号在低位的话，可以通过位运算让时间戳移动到高位，再通过或运算让序列号填充在低位。
```java
timestamp << COUNT_BITS | count
```
**整体代码实现：**
```java
public class RedisIdWorker {
    /**
     * 开始时间戳：以2020年0点0分为起点
     */
    private static final long BEGIN_TIMESTAMP = 1640995200L;
    /**
     * 序列号的位数
     */
    private static final int COUNT_BITS = 32;

    private StringRedisTemplate stringRedisTemplate;

    public RedisIdWorker(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }
    //  keyPrefix:可以看做是业务前缀，比如订单业务，店铺业务等
    public long nextId(String keyPrefix) {
        // 1.生成时间戳
        LocalDateTime now = LocalDateTime.now();
        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);
        long timestamp = nowSecond - BEGIN_TIMESTAMP;

        // 2.生成序列号
        // 2.1.获取当前日期，精确到天
        String date = now.format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));
        // 2.2.自增长
        long count = stringRedisTemplate.opsForValue().increment("icr:" + keyPrefix + ":" + date);

        // 3.拼接并返回
        return timestamp << COUNT_BITS | count;
    }
}
```
## 实现优惠秒杀下单
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691844655965-b8745f39-007f-4d8b-bd28-3b117469e29a.png#averageHue=%23e9eaed&clientId=ud5927d69-6b98-4&from=paste&height=272&id=uadb05e85&originHeight=272&originWidth=1347&originalType=binary&ratio=1&rotation=0&showTitle=false&size=148852&status=done&style=none&taskId=u276d7b09-c2b4-43b5-ad72-251a622cacd&title=&width=1347)
**平价劵**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691844737553-6cc8dc1b-b61a-45c7-8198-9be7709e8461.png#averageHue=%23dff1e7&clientId=ud5927d69-6b98-4&from=paste&height=335&id=uf127a6d6&originHeight=335&originWidth=1113&originalType=binary&ratio=1&rotation=0&showTitle=false&size=314700&status=done&style=none&taskId=ub02cdf58-98ba-4eb5-8436-cdb077a15f2&title=&width=1113)
**特价劵（劵信息的补充）**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691844820713-ee7da33c-c5e2-4cdd-ad49-533e3d71aefd.png#averageHue=%23edf5ef&clientId=ud5927d69-6b98-4&from=paste&height=253&id=ufe3bb789&originHeight=253&originWidth=1118&originalType=binary&ratio=1&rotation=0&showTitle=false&size=230032&status=done&style=none&taskId=ua8e7b92d-e734-462c-8265-6449561411c&title=&width=1118)
**订单**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691845192779-e5d01262-3de0-4c9a-98d0-cbefb1253b43.png#averageHue=%23e0f1e8&clientId=ud5927d69-6b98-4&from=paste&height=305&id=u06433cd3&originHeight=305&originWidth=976&originalType=binary&ratio=1&rotation=0&showTitle=false&size=279031&status=done&style=none&taskId=u2f67b431-df36-4ff8-94c4-434bff20517&title=&width=976)
**接口**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691845102323-a76d8506-c3f1-4f80-a2f3-42541dd25ec0.png#averageHue=%23b1b49b&clientId=ud5927d69-6b98-4&from=paste&height=699&id=u615992db&originHeight=699&originWidth=1505&originalType=binary&ratio=1&rotation=0&showTitle=false&size=344946&status=done&style=none&taskId=u59a16187-b276-4fae-a452-32eae57a2df&title=&width=1505)
**下单时需要判断两点：**

- 秒杀是否开始或结束，如果尚未开始或已经结束则无法下单
- 库存是否充足，不足则无法下单

![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691845526205-c56e4100-4bce-4379-bede-1417db915814.png#averageHue=%23fdfbfa&clientId=ud5927d69-6b98-4&from=paste&height=565&id=ueb7ccadf&originHeight=565&originWidth=971&originalType=binary&ratio=1&rotation=0&showTitle=false&size=108396&status=done&style=none&taskId=ufff989c9-223b-4192-8c8d-233b9477dbf&title=&width=971)
## 超卖问题
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691846050334-de2b05fc-9f48-435f-bdca-8ed14b33b11d.png#averageHue=%23fcf9f6&clientId=uda81f568-0c8f-4&from=paste&height=596&id=u6e125606&originHeight=596&originWidth=1446&originalType=binary&ratio=1&rotation=0&showTitle=false&size=275395&status=done&style=none&taskId=u481b5979-e7e6-47f9-bf29-125a9d51457&title=&width=1446)
> 如果使用乐观锁，每次只能以数据是否变更为依据，那该怎么优化？

分段锁。将库存分到多张表里，每次锁一个表中的数据（类似jdk1.7中的ConcurrentHashMap分段锁的思想）
### 乐观锁
**版本号法**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691846257299-8bf5d16a-bf56-49cb-9df7-bdeebad0134f.png#averageHue=%23fcf7f7&clientId=uda81f568-0c8f-4&from=paste&height=639&id=u9f5ddd0a&originHeight=639&originWidth=1544&originalType=binary&ratio=1&rotation=0&showTitle=false&size=167682&status=done&style=none&taskId=u02c13dca-e8d7-484f-9a92-6eb38ac9302&title=&width=1544)
**CAS法**（通过库存数据本身有没有变化来判断能不能进行减库存操作）
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691846474602-10e92962-ad1f-4c3d-a2eb-12f4e4e79010.png#averageHue=%23fdfafa&clientId=uda81f568-0c8f-4&from=paste&height=611&id=ud4ceaa31&originHeight=611&originWidth=1567&originalType=binary&ratio=1&rotation=0&showTitle=false&size=130203&status=done&style=none&taskId=ue53a49fd-85cf-4bf1-af08-4d7cba9b852&title=&width=1567)
```java
//获取库存
int stock =  seckillVoucherService.getStockById(Id);
// 6.扣减库存
boolean success = seckillVoucherService.update()
        .setSql("stock = stock - 1") // set stock = stock - 1
        .eq("voucher_id", voucherId).eq("stock", stock) // where id = ? and stock > 0
        .update();
```
**并发测试（在进行CAS优化超卖问题后，进行并发测试，异常比例大大增加）**
**模拟200个并发请求**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691846622133-e8f0e578-a57b-4583-9a50-fdbfbae5ebb8.png#averageHue=%238eb5d3&clientId=uda81f568-0c8f-4&from=paste&height=607&id=u63600ff4&originHeight=607&originWidth=1913&originalType=binary&ratio=1&rotation=0&showTitle=false&size=212466&status=done&style=none&taskId=ub530168a-4255-4db4-aa32-02ba21a8f5f&title=&width=1913)
**异常值高达90%**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691846651235-3281525b-68f3-4dd4-a73c-dfc31afb54cf.png#averageHue=%23d5dae0&clientId=uda81f568-0c8f-4&from=paste&height=310&id=uecd39eeb&originHeight=310&originWidth=1435&originalType=binary&ratio=1&rotation=0&showTitle=false&size=160446&status=done&style=none&taskId=u58481b8a-1fd6-47d3-9565-773cdcca461&title=&width=1435)
**在最开始的请求中就出现库存不足的错误信息**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691846712624-ebd9d4d6-0a18-4c70-b5a9-b71d10bcc036.png#averageHue=%23c4d7c3&clientId=uda81f568-0c8f-4&from=paste&height=900&id=u06417456&originHeight=900&originWidth=1417&originalType=binary&ratio=1&rotation=0&showTitle=false&size=297649&status=done&style=none&taskId=u543b0153-a1d2-47f3-b7de-498e6cbce62&title=&width=1417)
**库存卖出21件**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691846749081-5ec0e62c-5b68-46d3-af93-fe144f6f4c7f.png#averageHue=%23cdd7c0&clientId=uda81f568-0c8f-4&from=paste&height=209&id=u8521f7f1&originHeight=209&originWidth=809&originalType=binary&ratio=1&rotation=0&showTitle=false&size=67480&status=done&style=none&taskId=ua1af1245-7df6-46f3-892f-b920da31059&title=&width=809)
**生成21条订单数据（没有出现超卖问题）**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691846777012-571ce082-79b0-4848-815b-ebc893d2a74a.png#averageHue=%23c8dfec&clientId=uda81f568-0c8f-4&from=paste&height=637&id=u0e88d945&originHeight=637&originWidth=792&originalType=binary&ratio=1&rotation=0&showTitle=false&size=295074&status=done&style=none&taskId=u88636f7b-666a-4d30-91c6-5cd1df81d80&title=&width=792)
**分析问题原因（认为只要有线程更改，就会产生并发安全问题）：**
在库存数量充足的情况下，同一时间仍然只能有一个线程能对库存更新成功，其他线程由于查询库存数量变化，均导致更新失败，成功率过低。
**优化：**
```java
// 6.扣减库存
boolean success = seckillVoucherService.update()
        .setSql("stock = stock - 1") // set stock = stock - 1
        .eq("voucher_id", voucherId).gt("stock", 0) // where id = ? and stock > 0
        .update();
```
**并发测试**
**200个并发请求，100个线程下单成功，异常50%，符合预期**![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691847222855-fbed7b27-f50a-420a-ae29-e39db034181c.png#averageHue=%23d3d4d6&clientId=uda81f568-0c8f-4&from=paste&height=306&id=u9e064292&originHeight=306&originWidth=1437&originalType=binary&ratio=1&rotation=0&showTitle=false&size=170692&status=done&style=none&taskId=u69439485-3ffc-4d09-99fd-a3194f8bdd7&title=&width=1437)
**数据库中优惠券库存为0**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691847243830-dadd6671-2c1d-4880-a8f5-103b053dc73a.png#averageHue=%23accbe1&clientId=uda81f568-0c8f-4&from=paste&height=122&id=u68902904&originHeight=122&originWidth=802&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74124&status=done&style=none&taskId=u79716229-e08a-44e5-a78b-08cb35e3b1b&title=&width=802)
**数据库中订单数量为100**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691847265120-b832787f-f2e1-407b-b9c4-34aef8de572d.png#averageHue=%23fefefe&clientId=uda81f568-0c8f-4&from=paste&height=849&id=u1265f882&originHeight=901&originWidth=791&originalType=binary&ratio=1&rotation=0&showTitle=false&size=78221&status=done&style=none&taskId=u5e54d9dc-3b0a-4d64-8408-83103aa8fd0&title=&width=745)
## 一人一单
> 实现思路是什么？

当用户下单时，先根据用户id和优惠券id查询订单表中是否已经存在了该订单，如果存在，则返回异常结果。如果不存在，则走下单逻辑。
**解决思路：根据查询出来的订单数量，判断是否重复下单**
```java
// 5.1.查询订单
int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
// 5.2.判断是否存在
if (count > 0) {
    // 用户已经购买过了
    log.error("不允许重复下单！");
    return;
}
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691848112144-f331617b-67fa-4331-a567-cc62787612b6.png#averageHue=%23fdfafa&clientId=uda81f568-0c8f-4&from=paste&height=593&id=u58582560&originHeight=593&originWidth=1224&originalType=binary&ratio=1&rotation=0&showTitle=false&size=144876&status=done&style=none&taskId=u58f0cea1-b158-41dd-920d-8d791df4698&title=&width=1224)
**并发测试（模拟一个用户发起的200个请求）**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691848475495-4a53ff7b-233d-46bd-b28f-628c207bd4ec.png#averageHue=%23d7d6d9&clientId=uda81f568-0c8f-4&from=paste&height=558&id=uf0f37c7a&originHeight=558&originWidth=1426&originalType=binary&ratio=1&rotation=0&showTitle=false&size=137812&status=done&style=none&taskId=u24d74fa1-4702-49b1-bd4b-e34851ddfdb&title=&width=1426)
由于发送的请求头中携带的是相同的tocken，因此服务器识别为同一个用户![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691848525794-71f201ba-e538-4539-9a63-2b56f03d5e27.png#averageHue=%23639cd4&clientId=uda81f568-0c8f-4&from=paste&height=231&id=u497e0ae4&originHeight=231&originWidth=1412&originalType=binary&ratio=1&rotation=0&showTitle=false&size=81500&status=done&style=none&taskId=uc18ee74d-ed4a-47fa-8ae1-2133218d21d&title=&width=1412)
**失败比例95%**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691848618411-9842f33b-2418-4345-80e5-f0b6faa97bed.png#averageHue=%23dcdddf&clientId=uda81f568-0c8f-4&from=paste&height=309&id=u1046715a&originHeight=309&originWidth=1427&originalType=binary&ratio=1&rotation=0&showTitle=false&size=153738&status=done&style=none&taskId=ubba04a6b-48db-476f-b630-f7a4ae9dfce&title=&width=1427)
**库存数量：-10（100 -> 90）**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691848650549-64b74451-5d5b-4fd8-983a-4ccf6ed9c0f0.png#averageHue=%239cc2e0&clientId=uda81f568-0c8f-4&from=paste&height=146&id=uca8bd279&originHeight=146&originWidth=693&originalType=binary&ratio=1&rotation=0&showTitle=false&size=62768&status=done&style=none&taskId=u3dcdba25-d48d-44fe-a3d3-acb689c1a1d&title=&width=693)
**订单数量：10 （0 -> 10）**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691848661806-f89bddbc-1a44-48cf-9dd2-066f44272b62.png#averageHue=%23d6ebf2&clientId=uda81f568-0c8f-4&from=paste&height=382&id=ufa1642f4&originHeight=382&originWidth=793&originalType=binary&ratio=1&rotation=0&showTitle=false&size=172486&status=done&style=none&taskId=ue80bd95e-8302-45b6-92a8-049b8896f48&title=&width=793)
> 为什么实现了一人一单的逻辑后，仍然出现了一个用户下多个订单的问题？

这仍然是因为多线程并发时，多个线程同时查询得到了count为0，然后进行了扣减库存的操作。和库存超卖问题类似。
**解决思路：将查询订单数量和生成订单变成原子性操作**
**Sycronized锁解决**
```java
@Transactional
public Result createVoucherOrder(Long voucherId) {
    // 5.一人一单
    Long userId = UserHolder.getUser().getId();
	//如果直接锁userId，每次锁住的其实是不同的userId对象，因此没有作用
    synchronized (userId.toString().intern()) {
        // 5.1.查询订单
        int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
        // 5.2.判断是否存在
        if (count > 0) {
            // 用户已经购买过了
            return Result.fail("用户已经购买过一次！");
        }

        // 6.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock - 1") // set stock = stock - 1
                .eq("voucher_id", voucherId).gt("stock", 0) // where id = ? and stock > 0
                .update();
        if (!success) {
            // 扣减失败
            return Result.fail("库存不足！");
        }

        // 7.创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 7.1.订单id
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        // 7.2.用户id
        voucherOrder.setUserId(userId);
        // 7.3.代金券id
        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);

        // 7.返回订单id
        return Result.ok(orderId);
    }
}
```
如果仅仅采用上述这种方式，那么在事务提交前，锁已经释放，此时创建订单的记录还未写入到数据库中。因此可能有其他线程获取锁，并创建订单，仍然造成多线程并发不安全的情况。
**解决思路：先获取锁->执行逻辑，提交事务->再释放锁。**
```java
public Result seckillVoucher(Long voucherId) {
    // 1.查询优惠券
    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
    // 2.判断秒杀是否开始
    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
        // 尚未开始
        return Result.fail("秒杀尚未开始！");
    }
    // 3.判断秒杀是否已经结束
    if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
        // 尚未开始
        return Result.fail("秒杀已经结束！");
    }
    // 4.判断库存是否充足
    if (voucher.getStock() < 1) {
        // 库存不足
        return Result.fail("库存不足！");
    }
	// 5.一人一单
    Long userId = UserHolder.getUser().getId();
	synchronized (userId.toString().intern()) {
        Object proxy = AopContext.currentProxy();
        return proxy.createVoucherOrder(voucherId);
    }    
}
```
```java
@Transactional
public Result createVoucherOrder(Long voucherId) {
    // 5.一人一单
    Long userId = UserHolder.getUser().getId();
	//如果直接锁userId，每次锁住的其实是不同的userId对象，因此没有作用

    // 5.1.查询订单
    int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
    // 5.2.判断是否存在
    if (count > 0) {
        // 用户已经购买过了
        return Result.fail("用户已经购买过一次！");
    }

    // 6.扣减库存
    boolean success = seckillVoucherService.update()
            .setSql("stock = stock - 1") // set stock = stock - 1
            .eq("voucher_id", voucherId).gt("stock", 0) // where id = ? and stock > 0
            .update();
    if (!success) {
        // 扣减失败
        return Result.fail("库存不足！");
    }

    // 7.创建订单
    VoucherOrder voucherOrder = new VoucherOrder();
    // 7.1.订单id
    long orderId = redisIdWorker.nextId("order");
    voucherOrder.setId(orderId);
    // 7.2.用户id
    voucherOrder.setUserId(userId);
    // 7.3.代金券id
    voucherOrder.setVoucherId(voucherId);
    save(voucherOrder);

    // 7.返回订单id
    return Result.ok(orderId);

}

```
> 为什么没有直接调用createVoucherOrder()，而是通过调用代理对象的createVoucherOrder()的方法？

Spring中的事务失效的一种情况。如果直接调用createVoucherOrder()，由于它并不是代理对象，因此不具有事务功能。
**并发测试**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691903564085-12ab1425-3ed6-4822-b478-ebcc01072236.png#averageHue=%23d4d3d5&clientId=ua234527f-c3b6-4&from=paste&height=548&id=udafb0788&originHeight=548&originWidth=1422&originalType=binary&ratio=1&rotation=0&showTitle=false&size=133687&status=done&style=none&taskId=u02164f07-6948-429f-819f-2eda03e87c1&title=&width=1422)
200个请求中只有一个请求能下单成功，满足要求
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691903576250-d83f54d7-887f-4859-8877-fdd8af1a512b.png#averageHue=%23d9d9dd&clientId=ua234527f-c3b6-4&from=paste&height=311&id=ue2861c2d&originHeight=311&originWidth=1431&originalType=binary&ratio=1&rotation=0&showTitle=false&size=174392&status=done&style=none&taskId=u6f53b628-0965-4ed5-8513-6d39fa9e155&title=&width=1431)
库存-1
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691903589184-bd5eb2ba-639e-4a2e-a740-79be8485ec1e.png#averageHue=%23cee2e9&clientId=ua234527f-c3b6-4&from=paste&height=137&id=uc55bdfc8&originHeight=137&originWidth=799&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65373&status=done&style=none&taskId=u3d488bd5-5dfb-4a38-a5f6-38323b0e67c&title=&width=799)
订单+1
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691903599263-50a5035b-c8a4-474e-bfa6-27eaf3e7cbef.png#averageHue=%23a8c7e4&clientId=ua234527f-c3b6-4&from=paste&height=121&id=u1ac98808&originHeight=121&originWidth=808&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68074&status=done&style=none&taskId=u1e060394-f0b9-438e-a02c-7b85385ccc3&title=&width=808)
> 上述这种方式会出现什么问题？

在单体式情况下能保证一人一单的业务需求。但若将业务系统部署到多台服务器上，仍然会出现并发问题。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691904327454-59f1c186-3c90-476a-b1c0-02f9c52927d0.png#averageHue=%23cdced2&clientId=ua234527f-c3b6-4&from=paste&height=707&id=u3e7ca54b&originHeight=707&originWidth=1598&originalType=binary&ratio=1&rotation=0&showTitle=false&size=313431&status=done&style=none&taskId=u94a5b1c2-f9c4-48da-bf7a-dff7ab9ac50&title=&width=1598)
虽然仍然是对同一个userId上锁，但由于不同的服务器都拥有自己的JVM，JVM常量池中的userId对象是不同的，因此它们关联的锁监视器也不同。当服务器1中的线程1获取了互斥锁后，有线程2想要获取服务器2的互斥锁，它发现锁监视器为空，因此仍然能获取互斥锁成功，导致仍然出现一人下多单的问题。
**解决思路：让所有的JVM共享一把锁（分布式锁）**
# 四、分布式锁
**分布式锁：**满足分布式系统或集群模式下多进程可见并且互斥的锁。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691909044417-5b9865c8-4d19-4d9c-86b9-5509ea2a3a48.png#averageHue=%23b7b9bb&clientId=ua234527f-c3b6-4&from=paste&height=789&id=uac4a8e66&originHeight=789&originWidth=1611&originalType=binary&ratio=1&rotation=0&showTitle=false&size=312664&status=done&style=none&taskId=u28c969d6-609c-4774-80fe-125adbc00a0&title=&width=1611)
**可见性：**多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思
**互斥：**互斥是分布式锁的最基本的条件，使得程序串行执行
**高可用（主要看是否支持集群模式）**：程序不易崩溃，时时刻刻都保证较高的可用性
**高性能**：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能
**安全性（比如锁的释放）**：安全也是程序中必不可少的一环
**常见的分布式锁：**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691909737356-1923d9dd-27d3-430c-9700-afb4d166d041.png#averageHue=%23d7c2c1&clientId=ua234527f-c3b6-4&from=paste&height=538&id=ub18ae6a2&originHeight=538&originWidth=1497&originalType=binary&ratio=1&rotation=0&showTitle=false&size=148630&status=done&style=none&taskId=u31b16f8c-8225-4f47-8540-4101ff9f1b8&title=&width=1497)
## 分布式锁实现
实现分布式锁时需要实现的两个基本方法：

- 获取锁：
   - 互斥：确保只能有一个线程获取锁
   - 非阻塞：尝试一次，成功返回true，失败返回false
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691910045860-7271dd6a-d002-4009-8955-cb0d107190ce.png#averageHue=%231b3545&clientId=ua234527f-c3b6-4&from=paste&height=152&id=ud19e5e01&originHeight=152&originWidth=691&originalType=binary&ratio=1&rotation=0&showTitle=false&size=80151&status=done&style=none&taskId=u28a8b4ba-9417-4361-bfeb-edd8dd46eb7&title=&width=691)
- 释放锁：
   - 手动释放
   - 超时释放：获取锁时添加一个超时时间
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691910070586-ebf82fae-9478-43c1-9333-0462c9e09b70.png#averageHue=%231c3244&clientId=ua234527f-c3b6-4&from=paste&height=83&id=u9e4004cc&originHeight=83&originWidth=673&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24331&status=done&style=none&taskId=u57527479-de15-4013-b241-73322366a1c&title=&width=673)

核心思路：
利用redis 的setNx命令，第一个线程执行了SETNX后，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的线程，等待一定时间后重试即可
> 问题：执行EXPIRE指令可以为锁设置过期时间，但是如果在SETNX之后，EXPIRE之前，服务器宕机了，导致没有为锁设置上过期时间，怎么办？

在SET命令后可以跟上许多参数，其中就包括NX与EX，如果加上了NX，那么此时效果就和SETNX等价。同时在加上EX设置过期时间，将这两条指令结合为一条指令。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691910332978-f2a109b9-973b-4de7-a714-155f61ecfe9f.png#averageHue=%23263e4c&clientId=ua234527f-c3b6-4&from=paste&height=86&id=u1c1a17bf&originHeight=86&originWidth=672&originalType=binary&ratio=1&rotation=0&showTitle=false&size=50647&status=done&style=none&taskId=uf5796906-9897-4af8-8cad-b92cf91547d&title=&width=672)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691910805300-2a0bbc5d-b0ad-465d-92f1-e5406056a35c.png#averageHue=%23fefdfd&clientId=ua234527f-c3b6-4&from=paste&height=663&id=u2b0aad8f&originHeight=663&originWidth=560&originalType=binary&ratio=1&rotation=0&showTitle=false&size=85039&status=done&style=none&taskId=uaca55f8d-ee1b-4a8b-b549-ea1df1842b8&title=&width=560)
**锁接口**
```java
public interface ILock {

    /**
     * 尝试获取锁
     * @param timeoutSec 锁持有的超时时间，过期后自动释放
     * @return true代表获取锁成功; false代表获取锁失败
     */
    boolean tryLock(long timeoutSec);

    /**
     * 释放锁
     */
    void unlock();
}
```
## 实现版本1（使用Redis的SetNX分布式锁来为创建订单业务加锁）
```java
public class SimpleRedisLock implements ILock {

    private String name;
    private StringRedisTemplate stringRedisTemplate;

    public SimpleRedisLock(String name, StringRedisTemplate stringRedisTemplate) {
        this.name = name;
        this.stringRedisTemplate = stringRedisTemplate;
    }

    private static final String KEY_PREFIX = "lock:";
    
    //key为业务相关，值为线程id
    @Override
    public boolean tryLock(long timeoutSec) {
        // 获取线程标示
        String threadId =  Thread.currentThread().getId();
        // 获取锁
        Boolean success = stringRedisTemplate.opsForValue()
                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);
        //由于会拆箱，防止空指针异常
        return Boolean.TRUE.equals(success);
    }
    @Override
    public void unlock() {
            // 释放锁
            stringRedisTemplate.delete(KEY_PREFIX + name);
        }
    }
}
```
业务代码优化（一人一单，替换Sycronized）
```java
@Override
public Result seckillVoucher(Long voucherId) {
    // 1.查询优惠券
    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
    // 2.判断秒杀是否开始
    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
        // 尚未开始
        return Result.fail("秒杀尚未开始！");
    }
    // 3.判断秒杀是否已经结束
    if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
        // 尚未开始
        return Result.fail("秒杀已经结束！");
    }
    // 4.判断库存是否充足
    if (voucher.getStock() < 1) {
        // 库存不足
        return Result.fail("库存不足！");
    }
    Long userId = UserHolder.getUser().getId();
	//--------------------------------------------------------------------------------
    //创建锁对象(新增代码)
    SimpleRedisLock lock = new SimpleRedisLock("order:" + userId, stringRedisTemplate);
    //获取锁对象
    boolean isLock = lock.tryLock(1200);
    //加锁失败
    if (!isLock) {
        return Result.fail("不允许重复下单");
    }
    try {
        //获取代理对象(事务)
        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
        return proxy.createVoucherOrder(voucherId);
    } finally {
        //释放锁
        lock.unlock();
    }
}
```
> 上述方法仍然会存在哪些问题？

线程1获取锁后由于某个原因阻塞，导致业务还没执行完，锁的过期时间已经到了，因此锁自动释放。此时线程2获取锁并执行业务，而线程1业务恢复，执行业务完毕后仍然会执行释放锁的代码。此时线程3可以获取锁，继续执行业务，导致仍然会出现并发安全问题。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691912128297-b050bcae-b641-45ef-bdc0-720f9e37cec0.png#averageHue=%23fefdfd&clientId=ua234527f-c3b6-4&from=paste&height=634&id=u16c2925a&originHeight=634&originWidth=1551&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136146&status=done&style=none&taskId=ud22998a2-79de-4747-a033-7c3cfad9a92&title=&width=1551)
> 如何解决上述问题？

在线程释放锁的时候去判断锁标识是否和当前一致，如果一致，才释放锁。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691912497542-9e0b400d-4cfb-4276-97cd-690b0d95c6c0.png#averageHue=%23efeeef&clientId=ua234527f-c3b6-4&from=paste&height=403&id=RNNgT&originHeight=647&originWidth=624&originalType=binary&ratio=1&rotation=0&showTitle=false&size=118144&status=done&style=none&taskId=u20edf754-9371-4387-b985-049bdfdcbb5&title=&width=389)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691912371310-efc6af15-4767-4b32-9cc1-9274af71ca3c.png#averageHue=%23fefdfd&clientId=ua234527f-c3b6-4&from=paste&height=644&id=u3a0eb63f&originHeight=644&originWidth=1548&originalType=binary&ratio=1&rotation=0&showTitle=false&size=171005&status=done&style=none&taskId=u7d8f8856-5c41-439a-be1f-3088a1618dc&title=&width=1548)
## 实现版本2（解决线程误删锁问题）
需求：修改之前的分布式锁实现，满足：**在获取锁时存入线程标示（可以用UUID表示）在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致**

- 如果一致则释放锁
- 如果不一致则不释放锁

核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。
> 为什么使用UUID，而不是直接使用线程ID？

由于线程ID在每个JVM内部都是递增的，因此可能会出现不同的服务器中线程ID相同的情况，导致出现冲突。
**获取锁**
```java
private static final String ID_PREFIX = UUID.randomUUID().toString(true) + "-";
@Override
public boolean tryLock(long timeoutSec) {
   // 获取线程标示
   String threadId = ID_PREFIX + Thread.currentThread().getId();
   // 获取锁
   Boolean success = stringRedisTemplate.opsForValue()
                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);
   return Boolean.TRUE.equals(success);
}
```
**释放锁**
```java
public void unlock() {
    // 获取线程标示
    String threadId = ID_PREFIX + Thread.currentThread().getId();
    // 获取锁中的标示
    String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);
    // 判断标示是否一致
    if(threadId.equals(id)) {
        // 释放锁
        stringRedisTemplate.delete(KEY_PREFIX + name);
    }
}
```
> 上述代码仍然存在什么问题？（极端误删情况）

线程1执行业务，在判断锁标识是否一致，要释放锁之前，发生了阻塞（比如FULL GC）。在阻塞过程中，锁超时释放。此时线程2获取锁并执行，但线程1恢复执行，那么就释放掉线程2的锁，导致仍然出现并发安全问题。
**问题原因所在：锁标志判断和释放非原子性**![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691913419720-4f48a831-e513-4cde-9595-b7a6157d0586.png#averageHue=%23c3dea4&clientId=ua234527f-c3b6-4&from=paste&height=680&id=u5b010516&originHeight=680&originWidth=1628&originalType=binary&ratio=1&rotation=0&showTitle=false&size=294513&status=done&style=none&taskId=ufbe5cd56-54b1-4b3c-8c85-1428f9db0c6&title=&width=1628)
## 实现版本3（Lua脚本将查询锁标志和释放锁变成原子性操作）
Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：[https://www.runoob.com/lua/lua-tutorial.html](https://www.runoob.com/lua/lua-tutorial.html)，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。
这里重点介绍Redis提供的调用函数，语法如下：
redis.call('命令名称', 'key', '其它参数', ...)
例如，我们要执行set name jack，则脚本是这样：
```lua
# 执行 set name jack
redis.call('set', 'name', 'jack')
```
例如，我们要先执行set name Rose，再执行get name，则脚本如下：
```lua
# 先执行 set name jack
redis.call('set', 'name', 'Rose')
# 再执行 get name
local name = redis.call('get', 'name')
# 返回
return name
```
通过EVAL命令执行脚本
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691915652096-481e213a-ed0c-496b-998f-ac679db5e84c.png#averageHue=%23021e30&clientId=ua234527f-c3b6-4&from=paste&height=176&id=u6cd9ca99&originHeight=176&originWidth=739&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17831&status=done&style=none&taskId=u77e21197-df64-4aba-aedd-7c391b4590c&title=&width=739)
接下来我们来回一下我们释放锁的逻辑：
释放锁的业务流程是这样的
	1、获取锁中的线程标示
	2、判断是否与指定的标示（当前线程标示）一致
	3、如果一致则释放锁（删除）
	4、如果不一致则什么都不做
如果用Lua脚本来表示则是这样的：
最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样
```lua
-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示
-- 获取锁中的标示，判断是否与当前线程标示一致
if (redis.call('GET', KEYS[1]) == ARGV[1]) then
  -- 一致，则删除锁
  return redis.call('DEL', KEYS[1])
end
-- 不一致，则直接返回
return 0
```
**代码实现**
```java
//设置static，在类初始化就加载脚本，不必之后每次使用时重复加载脚本
private static final DefaultRedisScript<Long> UNLOCK_SCRIPT; //Redis脚本
static {
    UNLOCK_SCRIPT = new DefaultRedisScript<>();
    //设置脚本存放位置
    UNLOCK_SCRIPT.setLocation(new ClassPathResource("unlock.lua"));
    //设置脚本返回值类型
    UNLOCK_SCRIPT.setResultType(Long.class);
}

public void unlock() {
    // 调用lua脚本
    stringRedisTemplate.execute(
        UNLOCK_SCRIPT,
        Collections.singletonList(KEY_PREFIX + name),
        ID_PREFIX + Thread.currentThread().getId());
}
// 经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~
```
# 五、分布式锁（Redission）
基于setnx实现的分布式锁存在下面的问题：
**重入问题**：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。
**不可重试**：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。
**超时释放：**我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患
**主从一致性：** 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691918386005-3eb25723-66ca-4c19-8571-ebc4251c050c.png#averageHue=%23f9f8f8&clientId=ua234527f-c3b6-4&from=paste&height=621&id=u8ba72b4f&originHeight=621&originWidth=1541&originalType=binary&ratio=1&rotation=0&showTitle=false&size=180941&status=done&style=none&taskId=uc65601e8-751f-4fac-bc51-49e0f05a03c&title=&width=1541)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691996038304-724a201b-4ebe-4466-9e53-653c135d151b.png#averageHue=%23fcfcfc&clientId=ue8c6be50-3eec-4&from=paste&height=449&id=uf61c17d2&originHeight=449&originWidth=935&originalType=binary&ratio=1&rotation=0&showTitle=false&size=101110&status=done&style=none&taskId=u0b96cab0-da55-47f1-a860-b02c1ff5bcd&title=&width=935)
## Redisson可重入锁原理
Redission可重入锁的设计思想和Reentranlock相似，通过value值来记录当前锁的重入次数。在分布式锁中，采用hash结构来存储锁，大key表示这把锁是否存在，小key指向持有锁的线程，value指向当前被重入的次数。因此当一个线程想持有锁时，它首先判断该锁是否存在，如果不存在，则获取锁，并在hash结构中添加key\value。如果线程中有另一个方法仍然想获取该锁，则首先判断是否指向同一个线程id，如果是，则vlaue值+1。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691927280479-720af33d-b124-4d99-9b6e-a259544d1f10.png#averageHue=%23b8d3b7&clientId=ua234527f-c3b6-4&from=paste&height=787&id=u07372e99&originHeight=787&originWidth=1652&originalType=binary&ratio=1&rotation=0&showTitle=false&size=454354&status=done&style=none&taskId=ub92d1bc0-f1eb-44a4-9aea-ac9bc58fa4f&title=&width=1652)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691927409677-d8ebd8dc-7458-4c5a-b267-801e47c40d6c.png#averageHue=%23eef0ea&clientId=ua234527f-c3b6-4&from=paste&height=826&id=u6e91ae0b&originHeight=826&originWidth=964&originalType=binary&ratio=1&rotation=0&showTitle=false&size=442679&status=done&style=none&taskId=u2c8496a2-4d48-491c-aa6d-4273a4d447d&title=&width=964)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691927475165-b981fcd7-8d30-40e1-9076-217cb5588941.png#averageHue=%23eef0ec&clientId=ua234527f-c3b6-4&from=paste&height=750&id=ude782407&originHeight=750&originWidth=972&originalType=binary&ratio=1&rotation=0&showTitle=false&size=385033&status=done&style=none&taskId=ua29994ec-9065-4605-bdbf-3aaa0434f56&title=&width=972)
和Redisson实现可重入锁的逻辑一样，同样是通过哈希+lua脚本来实现的。
## Redisson锁重试及超时释放
## Redisson解决主从一致性（联锁multiLock）
> 问题引入：Redis的主节点执行了SETNX操作后，该命令还未同步到从节点，主节点就已经宕机。此时Redis通过哨兵模式选取一个新的从节点作为主节点，但是新主节点执行相同的SETNX后返回1，导致有两个线程同时获得了锁，出现并发安全问题。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691996404331-20d26caa-a176-4322-b5bd-db2826068206.png#averageHue=%23fbf3f3&clientId=ue8c6be50-3eec-4&from=paste&height=171&id=u01a51615&originHeight=615&originWidth=1267&originalType=binary&ratio=1&rotation=0&showTitle=false&size=150833&status=done&style=none&taskId=u7d09ee6f-247b-4bbb-bf22-98738999703&title=&width=353)![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691996440342-9d9ff998-35d0-4866-82fb-ab74b068559e.png#averageHue=%23f9efef&clientId=ue8c6be50-3eec-4&from=paste&height=183&id=uf9dfa143&originHeight=606&originWidth=1256&originalType=binary&ratio=1&rotation=0&showTitle=false&size=181182&status=done&style=none&taskId=u557fde06-19c7-4e27-9f6a-62a0505b279&title=&width=379)
> Redisson是如何解决这个问题的？

既然主从节点模式下，主从节点会出现数据不一致型的问题。因此Redis设置多个结点，并把每个结点都作为一个独立的结点，即可进行写也可进行读。如果一个线程要获取锁，那么它在多个结点下同时获得锁成功才算成功，只要有一个结点没有成功，那么就会获取锁失败。如果想提高可用性，可以为每个结点，再配置从节点。如果此时有一个主节点宕机，且锁数据还未同步到从节点，当一个线程要获取该锁时，尽管在该从节点设置SETNX返回1，但其他两个结点设置SETNX均返回0，因此即使从节点还未同步锁数据，由于这种机制，仍然保证了多线程下的并发安全问题。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691996763654-542e6a83-9e18-43ae-8ed5-f15b0ad5ac55.png#averageHue=%23f5e5e4&clientId=ue8c6be50-3eec-4&from=paste&height=164&id=ub943c86e&originHeight=584&originWidth=1250&originalType=binary&ratio=1&rotation=0&showTitle=false&size=206511&status=done&style=none&taskId=uda15309c-751f-4b46-964d-ad0ccdb250f&title=&width=350)![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691996778424-a1f9851a-7d64-48ef-ab9e-f5f682ab6e01.png#averageHue=%23e4caba&clientId=ue8c6be50-3eec-4&from=paste&height=144&id=uc735909a&originHeight=597&originWidth=1605&originalType=binary&ratio=1&rotation=0&showTitle=false&size=316539&status=done&style=none&taskId=u71fce9eb-ab19-40e6-a0f4-6f0be89a7aa&title=&width=386)
# 六、秒杀优化
**对目前优惠券系统进行并发测试（模拟1000个用户同时下单）**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691997722433-af03e4c9-dbfb-42f6-b8d8-e7c7d656d7a0.png#averageHue=%23cdcfd4&clientId=ue8c6be50-3eec-4&from=paste&height=476&id=u5b0e1fbd&originHeight=476&originWidth=1442&originalType=binary&ratio=1&rotation=0&showTitle=false&size=95620&status=done&style=none&taskId=u7f816aee-99cf-4f57-a81a-6d37008ef1d&title=&width=1442)
**平均响应时间达到497ms（业务耗时较长）**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691997756814-1200b8eb-7386-43f8-99d8-923c7635be3c.png#averageHue=%23d5d6d9&clientId=ue8c6be50-3eec-4&from=paste&height=279&id=u508a90a9&originHeight=279&originWidth=1452&originalType=binary&ratio=1&rotation=0&showTitle=false&size=113614&status=done&style=none&taskId=u7827f6c8-d119-4c5e-810f-fff5aa23bff&title=&width=1452)
> 分析业务执行时间较长的原因

秒杀业务进行各操作是一个串行的执行过程，并且在执行过程中会去数据库中查询或者执行写操作，相对较为耗时。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691997880859-1f4d77fa-62dc-480a-ac3f-8ad3c1acc7d2.png#averageHue=%23fefefe&clientId=ue8c6be50-3eec-4&from=paste&height=706&id=u0eba0c33&originHeight=706&originWidth=1561&originalType=binary&ratio=1&rotation=0&showTitle=false&size=230486&status=done&style=none&taskId=uab29624a-8eee-471f-aaba-dac4edb1d66&title=&width=1561)
> 如何进行优化？（提高并发能力、减轻数据库压力）

将查询优惠券库存、判断库存是否充足以及查询订单、校验一人一单的工作与减库存、创建订单的工作分离开，开启两个独立的线程去分别完成两个工作。
将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点
**第一个难点**是我们怎么在redis中去快速校验一人一单，还有库存判断
**第二个难点**是由于我们校验和tomcat下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。
**实现思路：**
Redis存储数据的结构
**库存数据：**key: 库存id，value:库存数量
**一人一单数据：**key：库存id，value：保存用户id的set集合。为了在Redis中校验一人一单的逻辑，因此只要一个用户下单成功，就把这个用户id放入到一个set集合中。后续用户想继续下单时，如果判断set中有这个值，就判断已经下过单。
当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，可以使用lua来操作。当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691998781170-db61aafd-3cb8-4b0c-9a79-9db00f33b1cc.png#averageHue=%23fbfcfc&clientId=ue8c6be50-3eec-4&from=paste&height=115&id=sqat8&originHeight=115&originWidth=1118&originalType=binary&ratio=1&rotation=0&showTitle=false&size=51229&status=done&style=none&taskId=u3438e490-d7a2-4d5f-86ca-3a5d91c9dfb&title=&width=1118)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1691998807723-d3375d08-df48-4b38-a249-7a93d86bc1dc.png#averageHue=%23f0f3f3&clientId=ue8c6be50-3eec-4&from=paste&height=607&id=ud8cd4b59&originHeight=607&originWidth=1594&originalType=binary&ratio=1&rotation=0&showTitle=false&size=248151&status=done&style=none&taskId=ua4f3a232-f071-4f74-90da-db213069204&title=&width=1594)

## 改进业务1（基于JDK阻塞队列实现秒杀）
需求：

- 新增秒杀优惠券的同时，将优惠券信息保存到Redis中
- 基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功
- 如果抢购成功，将优惠券id和用户id封装后存入阻塞队列
- 开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能
> 问题：保存优惠券库存信息到Redis中时，需要设置过期时间吗？

不需要，优惠券设置了秒杀开始时间与结束时间，当结束时间到了，添加删除优惠券的逻辑。如果删除逻辑失败，由于Redis有数据淘汰策略，由于这个优惠券下架后就不再会被使用，因此当Redis内存达到阈值之后，也会触发淘汰策略把它从Redis中淘汰掉。
**保存库存信息到Redis中**
```java
@Override
@Transactional
public void addSeckillVoucher(Voucher voucher) {
    // 保存优惠券
    save(voucher);
    // 保存秒杀信息
    SeckillVoucher seckillVoucher = new SeckillVoucher();
    seckillVoucher.setVoucherId(voucher.getId());
    seckillVoucher.setStock(voucher.getStock());
    seckillVoucher.setBeginTime(voucher.getBeginTime());
    seckillVoucher.setEndTime(voucher.getEndTime());
    seckillVoucherService.save(seckillVoucher);
    // 保存秒杀库存到Redis中
    //SECKILL_STOCK_KEY 这个变量定义在RedisConstans中
    //private static final String SECKILL_STOCK_KEY ="seckill:stock:"
    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());
}
```
**完整lua表达式**
```lua
-- 1.参数列表
-- 1.1.优惠券id
local voucherId = ARGV[1]
-- 1.2.用户id
local userId = ARGV[2]
-- 1.3.订单id
local orderId = ARGV[3]

-- 2.数据key
-- 2.1.库存key
local stockKey = 'seckill:stock:' .. voucherId
-- 2.2.订单key
local orderKey = 'seckill:order:' .. voucherId

-- 3.脚本业务
-- 3.1.判断库存是否充足 get stockKey
if(tonumber(redis.call('get', stockKey)) <= 0) then
  -- 3.2.库存不足，返回1
  return 1
end
-- 3.2.判断用户是否下单 SISMEMBER orderKey userId
if(redis.call('sismember', orderKey, userId) == 1) then
  -- 3.3.存在，说明是重复下单，返回2
  return 2
end
-- 3.4.扣库存 incrby stockKey -1
redis.call('incrby', stockKey, -1)
-- 3.5.下单（保存用户）sadd orderKey userId
redis.call('sadd', orderKey, userId)
-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...
redis.call('xadd', 'stream.orders', '*', 'userId', userId, 'voucherId', voucherId, 'id', orderId)
return 0
```
```java
//异步处理线程池
private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();

//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的
@PostConstruct
private void init() {
   SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());
}
// 用于线程池处理的任务
// 当初始化完毕后，就会去从对列中去拿信息
 private class VoucherOrderHandler implements Runnable{

        @Override
        public void run() {
            while (true){
                try {
                    // 1.获取队列中的订单信息
                    VoucherOrder voucherOrder = orderTasks.take();
                    // 2.创建订单
                    handleVoucherOrder(voucherOrder);
                } catch (Exception e) {
                    log.error("处理订单异常", e);
                }
          	 }
        }
     
       private void handleVoucherOrder(VoucherOrder voucherOrder) {
            //1.获取用户
            Long userId = voucherOrder.getUserId();
            // 2.创建锁对象
            RLock redisLock = redissonClient.getLock("lock:order:" + userId);
            // 3.尝试获取锁
            boolean isLock = redisLock.lock();
            // 4.判断是否获得锁成功
            if (!isLock) {
                // 获取锁失败，直接返回失败或者重试
                log.error("不允许重复下单！");
                return;
            }
            try {
				//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效
                proxy.createVoucherOrder(voucherOrder);
            } finally {
                // 释放锁
                redisLock.unlock();
            }
    }
     //a
	private BlockingQueue<VoucherOrder> orderTasks =new  ArrayBlockingQueue<>(1024 * 1024);

    @Override
    public Result seckillVoucher(Long voucherId) {
        Long userId = UserHolder.getUser().getId();
        long orderId = redisIdWorker.nextId("order");
        // 1.执行lua脚本
        Long result = stringRedisTemplate.execute(
                SECKILL_SCRIPT,
                Collections.emptyList(),
                voucherId.toString(), userId.toString(), String.valueOf(orderId)
        );
        int r = result.intValue();
        // 2.判断结果是否为0
        if (r != 0) {
            // 2.1.不为0 ，代表没有购买资格
            return Result.fail(r == 1 ? "库存不足" : "不能重复下单");
        }
        VoucherOrder voucherOrder = new VoucherOrder();
        // 2.3.订单id
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        // 2.4.用户id
        voucherOrder.setUserId(userId);
        // 2.5.代金券id
        voucherOrder.setVoucherId(voucherId);
        // 2.6.放入阻塞队列
        orderTasks.add(voucherOrder);
        //3.获取代理对象
         proxy = (IVoucherOrderService)AopContext.currentProxy();
        //4.返回订单id
        return Result.ok(orderId);
    }
     
      @Transactional
    public  void createVoucherOrder(VoucherOrder voucherOrder) {
        Long userId = voucherOrder.getUserId();
        // 5.1.查询订单
        int count = query().eq("user_id", userId).eq("voucher_id", voucherOrder.getVoucherId()).count();
        // 5.2.判断是否存在
        if (count > 0) {
            // 用户已经购买过了
           log.error("用户已经购买过了");
           return ;
        }

        // 6.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock - 1") // set stock = stock - 1
                .eq("voucher_id", voucherOrder.getVoucherId()).gt("stock", 0) // where id = ? and stock > 0
                .update();
        if (!success) {
            // 扣减失败
            log.error("库存不足");
            return ;
        }
        save(voucherOrder);
 
    }
```
> 当前的秒杀业务还存在哪些问题？

1. **内存限制。**当前的秒杀任务是基于jdk的阻塞队列实现，这个阻塞队列使用的JVM的内存，如果对阻塞队列不进行限制，那么高并发情况下会有很多订单对象创建并放到阻塞队列中，导致出现内存溢出的风险。因此创建阻塞队列时要为其设置一个长度上限，如果队列存满，那么新的订单就无法添加到队列中。
2. **数据安全（JVM内存没有持久化机制）。**如果系统宕机导致存储到队列中的数据丢失，那么用户收到了下单成功消息，但数据库中却没有，导致了出现不一致的问题。
## 改进业务2（基于Redis消息队列实现秒杀）
基于消息队列解决了上述两个问题。首先，消息队列独立于JVM之外，因此没有内存限制。另外，消息队列会对存放其中的消息进行持久化，如果消费者没有对消息进行确认，则消息在消息队列中一直存在。下一次再投递给消费者让消费者继续处理，直到消费者进行确认，才将此消息进行移除。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692002872587-8aab95d0-a24c-4554-808d-3dde32bea798.png#averageHue=%23989795&clientId=ue8c6be50-3eec-4&from=paste&height=227&id=u68429a68&originHeight=227&originWidth=952&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66440&status=done&style=none&taskId=u8713d21a-1e09-4ffd-9193-ad3f4dc2c7a&title=&width=952)
### 基于Redis的list实现消息队列
Redis的list结构底层是通过双向链表实现的，因此限制生产者从一边push（LPUSH命令），而消费者从另一边pop（RPOP命令），即实现了消息队列的模型。另外，当消息队列中没有消息时，我们希望处于阻塞状态，因此可以使用List的BLPOP、BRPOP命令，当list中无消息时，便会处于阻塞等待的状态。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692003303374-5670d572-69ee-4896-9488-c5095dd63fc7.png#averageHue=%23c3c693&clientId=ue8c6be50-3eec-4&from=paste&height=181&id=u270e7421&originHeight=181&originWidth=1332&originalType=binary&ratio=1&rotation=0&showTitle=false&size=55909&status=done&style=none&taskId=ue96a5d61-9b61-4d5a-8a3c-b750e013845&title=&width=1332)
> 基于List的消息队列有哪些优缺点？

优点：

- 利用Redis存储，不受限于JVM内存上限
- 基于Redis的持久化机制，数据安全性有保证
- 可以满足消息有序性

缺点：

- 无法避免消息丢失（执行完BRPOP之后，就把消息从list中移除，因此从list取出消息后如果出现了异常，消息就会丢失了）
- 只支持单消费者（拿出消息后就从队列中移除，其他消费者拿不到消息）
### 基于Redis的PubSub实现消息队列
PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。
SUBSCRIBE channel [channel] ：订阅一个或多个频道 PUBLISH channel msg ：向一个频道发送消息 PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692003967273-1cfb2094-88cf-4b05-a472-5d89906d8e61.png#averageHue=%23fcfafa&clientId=ue8c6be50-3eec-4&from=paste&height=451&id=u3e4b0ef9&originHeight=451&originWidth=1377&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92491&status=done&style=none&taskId=u0a2d4922-6513-4ae2-84be-19a5ee5539c&title=&width=1377)
基于PubSub的消息队列有哪些优缺点？优点：

- 采用发布订阅模型，支持多生产、多消费

缺点：

- 不支持数据持久化（Redis的数据是有持久化机制，但PubSub是另一种发布订阅模型，并不支持数据持久化）
- 无法避免消息丢失
- 消息堆积有上限，超出时数据丢失（消费者有缓存区域，如果处理一个消息时时间过久，其他消息到达后存储到缓存区中，缓存区满了后消息就会丢失）
### 基于Stream的消息队列
Stream 是 Redis 5.0 引入的一种新**数据类型（支持数据持久化）**，可以实现一个功能非常完善的消息队列。
#### 单消费模式
| 命令 | 介绍 |
| --- | --- |
| XADD | 向队列中添加消息 |
| XREAD | 读取队列中的消息 |
| XLEN | 读取队列中消息的长度 |

发送消息的命令：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692007946690-ce1c084f-a7e3-4136-a6d5-326504eb627b.png#averageHue=%23122d3e&clientId=ue8c6be50-3eec-4&from=paste&height=207&id=u7a0dfd91&originHeight=207&originWidth=1507&originalType=binary&ratio=1&rotation=0&showTitle=false&size=230016&status=done&style=none&taskId=uca71bfb5-13ec-4036-a2d4-688144a12e3&title=&width=1507)
例如：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692007952291-5b04ed5c-039b-4f02-8dca-3c69fa3734db.png#averageHue=%23052033&clientId=ue8c6be50-3eec-4&from=paste&height=189&id=u4988e901&originHeight=189&originWidth=1508&originalType=binary&ratio=1&rotation=0&showTitle=false&size=105190&status=done&style=none&taskId=ua0243fdb-2c8e-45cf-8406-bea8ffb8d1c&title=&width=1508)
读取消息的方式之一：XREAD
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692007957378-e264f019-5948-45a6-b372-1092aa555314.png#averageHue=%23132b3f&clientId=ue8c6be50-3eec-4&from=paste&height=296&id=u7b631bb7&originHeight=296&originWidth=1418&originalType=binary&ratio=1&rotation=0&showTitle=false&size=296114&status=done&style=none&taskId=u00d2aa64-ca4e-4d09-9c40-75d255d3961&title=&width=1418)
例如，使用XREAD读取第一个消息：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692007966804-4d1df85d-e58d-43d7-95f0-548daa89af06.png#averageHue=%23021e31&clientId=ue8c6be50-3eec-4&from=paste&height=250&id=u443333f4&originHeight=250&originWidth=1093&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19714&status=done&style=none&taskId=u65caaec0-95bb-46c0-ab87-40d5cbd0699&title=&width=1093)
XREAD阻塞方式，读取最新的消息：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692007974186-5cbeb2b9-3f61-439e-8181-097de8c9fe7e.png#averageHue=%23031e32&clientId=ue8c6be50-3eec-4&from=paste&height=106&id=ud0983c1f&originHeight=106&originWidth=978&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10247&status=done&style=none&taskId=u93230b3f-9a74-4d3a-b095-c9f316b9a76&title=&width=978)
**添加到Strem队列中的消息可以被多个消费者读取，不会出现其他消费者读了之后，消息就从队列中丢失掉的情况。**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692254234462-53bc4aee-b952-4ea2-81f5-41a4c1973b79.png#averageHue=%230b2439&clientId=uccbf30ef-1ea5-4&from=paste&height=958&id=u43b96ec7&originHeight=862&originWidth=1895&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=496712&status=done&style=none&taskId=u62ef3e9e-4de1-4949-8864-3dc9476fc58&title=&width=2105.5556113337307)
在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692007985689-ace6fa77-4b98-4e79-a8aa-8b942c0decb8.png#averageHue=%23f3f3f2&clientId=ue8c6be50-3eec-4&from=paste&height=358&id=u18e47f91&originHeight=358&originWidth=1045&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29721&status=done&style=none&taskId=u21a24b95-9731-4119-8328-b9dc2983889&title=&width=1045)
> 上述的队列实现存在什么问题？

消息漏读。我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题。
**STREAM类型消息队列的XREAD命令特点：**

- 消息可回溯（消息添加到队列后不会消失，可回看）
- 一个消息可以被多个消费者读取
- 可以阻塞读取
- 有消息漏读的风险
#### 消费者组
> #### 单消费和消费者组模式有什么区别？

消费者组是将多个消费者划分到一个组中，监听同一个队列。用来解决消息漏读的问题。
**特点：**

1. **消息分流。**队列中的消息会被分到组内的不同消费者，加快了消息处理的速度，避免出现消息堆积的情况。
2. **消息标示。**消费者组中维护了一个记录最后一个被处理的消息的标识，通过该标识，可以确保每个消息都会被消费， 避免出现消息漏读的情况。
3. **消息确认。**消费者获取消息之后，消息会处于pending状态，并且处于pending状态的消息会存入到pending-list中。如果消息处理完毕，需要XACK确认消息，标记消息已被处理，并会从pendinglist中移除。该机制确保了消息至少会被消费一次。如果Redis宕机，在恢复后可以到pending-list中找到还未完成处理的消息，继续处理。

**基本命令**
**创建消费者组**
```java
XGROUP CREAT key groupName ID [MKSTREAM]
```
**删除指定的消费者组**
```java
XGROUP DESTORY key groupName
```
**给指定的消费者组添加消费者**
```java
XGROUP CREATECONSUMER key groupname consumername
```
**删除消费者组中的指定消费者**
```java
XGROUP DELCONSUMER key groupname consumername
```
**从消费者组读取消息**
```java
XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] 
STREAMS key [key ...] ID [ID ...]
```

- group：消费组名称
- consumer：消费者名称，如果消费者不存在，会自动创建一个消费者
- count：本次查询的最大数量
- BLOCK milliseconds：当没有消息时最长等待时间
- NOACK：无需手动ACK，消息投递到消费者后会自动确认
- STREAMS key：指定队列名称
- ID：获取消息的起始ID：
   - ">"：从下一个未消费的消息开始（正常情况下读未消费的消息）
   - 其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始（出现异常时，从pending-list中读取已消费但未处理成功的消息）

**确认消息**
```java
XACK key group ID [ID ...]
```
**消费者组监听消息思路（确保消息至少会被消费一次）：**
正常情况下，由消费者组来监听队列中未被消费的消息；如果监听过程中出现了异常，则在捕获异常的处理逻辑中去处理已消费但还未确认的消息，当这些未确认的消息处理完毕后，再监听未被消费的消息。
**代码实现**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692256791855-d6eee032-6e5e-45ef-a7d8-16bd77d13d9b.png#averageHue=%23f3f2f6&clientId=uccbf30ef-1ea5-4&from=paste&height=907&id=u6aee48b3&originHeight=816&originWidth=912&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=239002&status=done&style=none&taskId=u21e98073-0428-4582-8842-d1892a5a2d6&title=&width=1013.3333601775)
STREAM类型消息队列的XREADGROUP命令特点：

- 消息可回溯
- 可以多消费者争抢消息，加快消费速度
- 可以阻塞读取
- 没有消息漏读的风险（有最后一次被处理消息的标识，每次读取时，可从上一次消费消息后的一条消息读取）
- 有消息确认机制，保证消息至少被消费一次

![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692257280587-6c1c8550-6d74-4d4a-8042-ee20101f650d.png#averageHue=%23d7d6d8&clientId=uccbf30ef-1ea5-4&from=paste&height=717&id=u096bc41a&originHeight=645&originWidth=1455&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=190656&status=done&style=none&taskId=u436dd6ae-1794-47fd-9073-fc3f35b6fd1&title=&width=1616.6667094937088)
> 使用Stream队列还存在什么缺点？

1. 依赖于Redis持久化，仍然存在消息丢失的风险
2. Stream只支持消费者确认，并不支持生产者确认，因此如果生产者消息丢失，还需要考虑如何解决
#### 代码实现
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692258928313-d557834b-c642-4227-a616-b482895a870c.png#averageHue=%23bab9b8&clientId=uccbf30ef-1ea5-4&from=paste&height=274&id=u8f2e5a0c&originHeight=247&originWidth=1345&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=100355&status=done&style=none&taskId=udd23af9a-188f-4069-a223-86b5d52253c&title=&width=1494.4444840337035)
**具体思路：**
在redis里进行库存判断+一人一单判断后，将库存id、用户id、订单id发送到消息队列中，完成后判断是否可以下单成功，如果可以，则直接返回数据。然后开启另外一个线程完成异步下单的功能。在进行异步下单时，开启的线程一直监听队列中的消息。如果监听到消息，则执行处理，并返回对该消息的确认。如果发生了异常，则要处理已消费但未确认的消息。
**lua脚本**
```java
-- 1.参数列表
-- 1.1.优惠券id
local voucherId = ARGV[1]
-- 1.2.用户id
local userId = ARGV[2]
-- 1.3.订单id
local orderId = ARGV[3]

-- 2.数据key
-- 2.1.库存key
local stockKey = 'seckill:stock:' .. voucherId
-- 2.2.订单key
local orderKey = 'seckill:order:' .. voucherId

-- 3.脚本业务
-- 3.1.判断库存是否充足 get stockKey
if(tonumber(redis.call('get', stockKey)) <= 0) then
  -- 3.2.库存不足，返回1
  return 1
end
-- 3.2.判断用户是否下单 SISMEMBER orderKey userId
if(redis.call('sismember', orderKey, userId) == 1) then
  -- 3.3.存在，说明是重复下单，返回2
  return 2
end
-- 3.4.扣库存 incrby stockKey -1
redis.call('incrby', stockKey, -1)
-- 3.5.下单（保存用户）sadd orderKey userId
redis.call('sadd', orderKey, userId)
-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...
redis.call('xadd', 'stream.orders', '*', 'userId', userId, 'voucherId', voucherId, 'id', orderId)
return 0
```
**VoucherOrderServiceImpl**
```java
private class VoucherOrderHandler implements Runnable {

    @Override
    public void run() {
        while (true) {
            try {
                // 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 >
                List<MapRecord<String, Object, Object>> list = stringRedisTemplate.opsForStream().read(
                    Consumer.from("g1", "c1"),
                    StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),
                    StreamOffset.create("stream.orders", ReadOffset.lastConsumed())
                );
                // 2.判断订单信息是否为空
                if (list == null || list.isEmpty()) {
                    // 如果为null，说明没有消息，继续下一次循环
                    continue;
                }
                // 解析数据
                MapRecord<String, Object, Object> record = list.get(0);
                Map<Object, Object> value = record.getValue();
                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);
                // 3.创建订单
                createVoucherOrder(voucherOrder);
                // 4.确认消息 XACK
                stringRedisTemplate.opsForStream().acknowledge("s1", "g1", record.getId());
            } catch (Exception e) {
                log.error("处理订单异常", e);
                //处理异常消息
                handlePendingList();
            }
        }
    }

    private void handlePendingList() {
        while (true) {
            try {
                // 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0
                List<MapRecord<String, Object, Object>> list = stringRedisTemplate.opsForStream().read(
                    Consumer.from("g1", "c1"),
                    StreamReadOptions.empty().count(1),
                    StreamOffset.create("stream.orders", ReadOffset.from("0"))
                );
                // 2.判断订单信息是否为空
                if (list == null || list.isEmpty()) {
                    // 如果为null，说明没有异常消息，结束循环
                    break;
                }
                // 解析数据
                MapRecord<String, Object, Object> record = list.get(0);
                Map<Object, Object> value = record.getValue();
                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);
                // 3.创建订单
                createVoucherOrder(voucherOrder);
                // 4.确认消息 XACK
                stringRedisTemplate.opsForStream().acknowledge("s1", "g1", record.getId());
            } catch (Exception e) {
                log.error("处理pendding订单异常", e);
                try{
                    Thread.sleep(20);
                }catch(Exception e){
                    e.printStackTrace();
                }
            }
        }
    }
    public Result seckillVoucher(Long voucherId) {
        Long userId = UserHolder.getUser().getId();
        long orderId = redisIdWorker.nextId("order");
        // 1.执行lua脚本
        Long result = stringRedisTemplate.execute(
                SECKILL_SCRIPT,
                Collections.emptyList(),
                voucherId.toString(), userId.toString(), String.valueOf(orderId)
        );
        int r = result.intValue();
        // 2.判断结果是否为0
        if (r != 0) {
            // 2.1.不为0 ，代表没有购买资格
            return Result.fail(r == 1 ? "库存不足" : "不能重复下单");
        }
        // 3.返回订单id
        return Result.ok(orderId);
    }
}

```
**并发测试**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692261304330-ceaae2cf-0685-4518-8c34-83df49266c69.png#averageHue=%23cdcdcf&clientId=uf36aa5ff-712d-4&from=paste&height=512&id=udaef5c94&originHeight=461&originWidth=1442&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=75186&status=done&style=none&taskId=ucc62ed68-d25c-4ab8-ab15-e557159b00b&title=&width=1602.2222646666173)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692261319614-ffd522f4-e61f-45c6-a0f2-b24032f009bd.png#averageHue=%23dfe0e3&clientId=uf36aa5ff-712d-4&from=paste&height=263&id=u9797bee9&originHeight=237&originWidth=1454&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=82364&status=done&style=none&taskId=uba37284e-e76e-4f69-b0d9-2c8826cb224&title=&width=1615.5555983531633)
# 七、达人探店
**数据表**
**tb_blog（探店笔记表）**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692269255815-9ffb9cfa-a8fb-4e10-948a-0e1aaed711f1.png#averageHue=%23d2efde&clientId=uf36aa5ff-712d-4&from=paste&height=571&id=uc6ae2178&originHeight=514&originWidth=1265&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=714622&status=done&style=none&taskId=u31c4e742-1202-4590-9ed4-8a2c000df93&title=&width=1405.555592790063)
**tb_blog_comments**

| 接口 | 介绍 | 返回值 |
| --- | --- | --- |
| /blog | 发布探店笔记接口 |  |
| /blog/{id} | 查看探店笔记接口 | 笔记信息+用户信息 |
| /blog/like/id | 点赞探店笔记接口 |  |
| /blog/likes/{id} |  |  |

**发布探店笔记**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692269512242-ad304109-3700-46c9-8954-542cea1eac37.png#averageHue=%23af9d85&clientId=uf36aa5ff-712d-4&from=paste&height=759&id=u7a360a6c&originHeight=683&originWidth=1633&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=643697&status=done&style=none&taskId=u0f23ca7a-35b4-4667-b8e2-e7f0d5e3b33&title=&width=1814.4444925108087)
上传照片和发布图文是两个不同的接口，用户需要上传图片时调用上传图片的接口，然后接口会返回图片的名称信息。后面调用发布笔记的接口时，会把图片的名称传到接口中。
**查看探店笔记**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692270253997-9e3f7b72-a914-433f-8e55-fda93f2bbea3.png#averageHue=%23bbbaa8&clientId=uf36aa5ff-712d-4&from=paste&height=737&id=ufc0c4235&originHeight=663&originWidth=1424&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=562051&status=done&style=none&taskId=u72845ed4-258d-420d-9191-09c5708add1&title=&width=1582.2222641367982)
**点赞探店笔记**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692270479494-8ef36dec-3b43-4396-8b63-f2930fe46eb4.png#averageHue=%238d7659&clientId=uf36aa5ff-712d-4&from=paste&height=776&id=u7ecd72c0&originHeight=698&originWidth=1567&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=1127404&status=done&style=none&taskId=ube3e56c0-66da-4ac2-800d-ac65ed28e0a&title=&width=1741.1111572348054)
**实现1**
```java
@GetMapping("/likes/{id}")
public Result queryBlogLikes(@PathVariable("id") Long id) {
    //修改点赞数量
    blogService.update().setSql("liked = liked +1 ").eq("id",id).update();
    return Result.ok();
}
```
> 问题：没有对点赞量进行限制，一个用户可以为同一篇探店笔记点多个赞

**实现2**
**需求**：

- 同一个用户只能点赞一次，再次点击则取消点赞
- 如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）

**实现步骤：**

- 给Blog类中添加一个isLike字段，标示是否被当前用户点赞
- 修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1
- 修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段
- 修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段
> 判断用户是否点过赞的思路有哪些？

1. 建立一个点赞表，里面包括Blog ID以及User ID，当要判断当前用户是否点过赞，则根据Blog ID和User ID到数据库中去查询。（数据库压力大、直接访问数据库，导致性能低）
2. 使用Redis的set集合

**点赞排行榜**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32637015/1692272447657-536b940c-4c64-4dec-b93d-f9175b26f912.png#averageHue=%23bebcae&clientId=uf36aa5ff-712d-4&from=paste&height=774&id=uf670ba53&originHeight=697&originWidth=1517&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=651252&status=done&style=none&taskId=u8ecb8973-cc9a-4f1f-8ea4-7f7d316fa42&title=&width=1685.5556002075302)

